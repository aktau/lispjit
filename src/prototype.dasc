// Most basic DynASM JIT; generates a trivial function that
// returns a given value, and executes it.
// code by Josh Haberman

/* note to self: on AVX-enabled processors, only generate instructions with
 * the v-prefix, i.e.: vhaddps not haddps. */

// DynASM directives.
|.arch x64
|.actionlist actions
|
/* note: destroys register, alternative impl possible */
|.macro call_external, reg, addr
|  mov64  reg, (uintptr_t)addr
|  call   reg
|.endmacro

|.include src/macro_math_x86.dasc

// This define affects "|" DynASM lines.  "Dst" must
// resolve to a dasm_State** that points to a dasm_State*.
#define Dst &state

int main(int argc, char *argv[]) {
  if (argc < 3) {
    fprintf(stderr, "Usage: %s <integer> <float>\n", argv[0]);
    return 1;
  }

  int num = atoi(argv[1]);
  const float fl = (float)atof(argv[2]);
  int fnum = float_bitmask(fl);

  dasm_State *state;
  /* dasm_init(&state, 1); */
  /* dasm_setup(&state, actions); */

  // Generate the code.  Each line appends to a buffer in
  // "state", but the code in this buffer is not fully linked
  // yet because labels can be referenced before they are
  // defined.
  //
  // The run-time value of C variable "num" is substituted
  // into the immediate value of the instruction.
  /* |  mov eax, num */
  /* |  ret */

  // Link the code and write it to executable memory.
  /* int (*fptr)() = jitcode(&state); */

  // Call the JIT-ted function.
  /* int ret = fptr(); */
  int ret = 42;
  /* assert(num == ret); */

  /* free the machine code. */

  /* free_jitcode(fptr); */
  /* dasm_free(&state); */

  dasm_init(&state, 1);
  dasm_setup(&state, actions);

  /* |  shufps xmm0, xmm0, 0 */

  /* do some pushes to see what kind of values we get */
  /* |  push dword fnum */
  /* |  push dword num */
  /* |  push dword fnum */
  /* |  push dword num */
  /* undo the stack modifications */
  /* |  add rsp, 4*8 */

  /* save the stack pointer to rbx */
  |  mov rbx, rsp
  /* align stack to 16 bytes, reserve 16 bytes, load dqword */
  |  and rsp, -16
  |  sub rsp, 16
  |  mov dword [rsp], fnum
  |  mov dword [rsp+4], fnum
  |  mov dword [rsp+8], fnum
  |  mov dword [rsp+12], fnum
  |  movaps xmm0, [rsp]
  /* push rbx (which contains the val of the stack ptr) on the stack */
  |  push rbx
  /* SSE 4 dot product, also try a macro of SSE2/3 instr later */
  /* |  dpps xmm0, xmm0, 0xf1 */
  /* |  dot_prod_sse4 xmm0, xmm0 */
  /* |  dot_prod_sse3 xmm0, xmm0 */
  |  dot_prod_sse2 xmm0, xmm0
  /* restore the saved stack pointer */
  |  pop rsp
  |  ret

  float (*fltf)(float) = jitcode(&state);
  float fret = fltf(fnum);
  printf("the float value is %f == %f (0x%x == 0x%x) memcpy: 0x%x\n", fl, fret,
          *(int *)&fl, *(int *)&fret, fnum);
  free_jitcode(fltf);

  dasm_free(&state);

  return ret;
}
