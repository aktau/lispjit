// Most basic DynASM JIT; generates a trivial function that
// returns a given value, and executes it.
// code by Josh Haberman

#include <stdbool.h>
#include <string.h>
#include <stdio.h>

#include "error.h"
#include "registers.h"
#include "parse.h"

/* note to self: on AVX-enabled processors, only generate instructions with
 * the v-prefix, i.e.: vhaddps not haddps. */

// DynASM directives.
|.arch x64
|.actionlist actions
|
/* note: destroys register, alternative impl possible */
|.macro call_external, reg, addr
|  mov64  reg, (uintptr_t)addr
|  call   reg
|.endmacro

|.include src/macro_math_x86.dasc

// This define affects "|" DynASM lines.  "Dst" must
// resolve to a dasm_State** that points to a dasm_State*.
#define Dst &dasm_state

static dasm_State *dasm_state;

typedef struct {
    reg_state_t regs;
} state_t;

static char errbuf[2048];

#define CMP_EQ  0 /* equal */
#define CMP_LT  1 /* less than */
#define CMP_LE  2 /* less than or equal */
#define CMP_UN  3 /* unordered */
#define CMP_NE  4 /* not equal */
#define CMP_NLT 5 /* not less than */
#define CMP_NLE 6 /* not less than or equal */
#define CMP_ORD 7 /* ord */

/* how to quickly load a bunch of constants into a vector?
 * http://stackoverflow.com/questions/6654099/how-to-move-128-bit-immediates-to-xmm-registers
 * currently going for something that doesn't require messing with the stack
 * pointer, it does require two vector registers though, which is painful as
 * well */
struct error vec_load(state_t *st, int *vidx, const char *buf) {
    const char *pos = buf;

    pos = strchr(buf, '(');
    if (!pos) {
        return RERR("no opening paren found", buf);
    }
    ++pos;

    float f[4];
    printf("buf: %s\n", pos);
    sscanf(pos, "%f %f %f %f", f, f + 1, f + 2, f + 3);
    printf("read floats: (%f %f %f %f)\n", f[0], f[1], f[2], f[3]);

    pos = strchr(buf, ')');
    if (!pos) {
        return RERR("no closing paren found", buf);
    }
    ++pos;

    int tidx = reg_get_64(st->regs);
    if (tidx == REG_NONE) {
        return RERR("no free temp register for vector load", buf);
    }

    *vidx = reg_get_128(st->regs);
    if (*vidx == REG_NONE) {
        return RERR("no free vector register for vector load", buf);
    }

    int tvidx = reg_get_128(st->regs);
    if (tvidx == REG_NONE) {
        return RERR("no free vector register for vector load", buf);
    }

    uint64_t low = *(uint64_t *) f;
    uint64_t high = *(uint64_t *) (f + 2);
    |  mov64 Rq(tidx), low
    |  movd xmm(*vidx), Rq(tidx)
    |  mov64 Rq(tidx), high
    |  movd xmm(tvidx), Rq(tidx)
    |  movlhps xmm(*vidx), xmm(tvidx)

    /* deallocate the temp registers */
    reg_put_64(st->regs, tidx);
    reg_put_128(st->regs, tvidx);

    return ROK(pos);
}

struct error compile(const char *buf) {
    const char *pos = buf;

    state_t st = {
        .regs = X64_REGS_INIT
    };

    /* find the first parentheses and skip it */
    pos = strchr(buf, '(');
    if (!pos) {
        return RERR("no paren found", buf);
    }
    ++pos;

    /* char operator = *pos; */
    operation_t op = decode(pos);
    switch (op) {
        /* binary operators */
        case OP_ADD:
        case OP_SUB:
        case OP_MUL:
        case OP_DIV:
        case OP_INV:
        case OP_SQRT:
        case OP_RSQRT:
        case OP_AND:
        case OP_NAND:
        case OP_OR:
        case OP_XOR:
        case OP_NEG:
        case OP_LT:
        case OP_LE:
        case OP_GT:
        case OP_GE:
        case OP_EQ:
        case OP_NEQ:
        case OP_MAX:
        case OP_MIN: {
            /* TODO: ensure that there's two arguments */

            /* plus takes two vector operands of equal or divisible size */
            int arg1 = 0;
            struct error err = vec_load(&st, &arg1, pos);
            if (err.msg) {
                return err;
            }
            pos = err.pos;

            int arg2 = 0;
            struct error err2 = vec_load(&st, &arg2, pos);
            if (err2.msg) {
                return err2;
            }
            pos = err2.pos;

            switch (op) {
                case OP_ADD:
                    | addps xmm(arg1), xmm(arg2)
                    break;
                case OP_SUB:
                    | subps xmm(arg1), xmm(arg2)
                    break;
                case OP_MUL:
                    | mulps xmm(arg1), xmm(arg2)
                    break;
                case OP_DIV:
                    | divps xmm(arg1), xmm(arg2)
                    break;
                case OP_INV:
                    /* TODO: this is actually unary */
                    | rcpps xmm(arg1), xmm(arg1)
                    break;
                case OP_SQRT:
                    | sqrtps xmm(arg1), xmm(arg2)
                    break;
                case OP_RSQRT:
                    | rsqrtps xmm(arg1), xmm(arg2)
                    break;
                case OP_AND:
                    | andps xmm(arg1), xmm(arg2)
                    break;
                case OP_NAND:
                    | andnps xmm(arg1), xmm(arg2)
                    break;
                case OP_OR:
                    | orps xmm(arg1), xmm(arg2)
                    break;
                case OP_XOR:
                    | xorps xmm(arg1), xmm(arg2)
                    break;
                case OP_NEG:
                    /* TODO: this is unary, not binary and also not
                     * implemented, could be done like so: */
                    /* _mm_xor_ps(vec, _mm_set1_ps(-0.f)) */
                    break;
                case OP_LT:
                    | cmpps xmm(arg1), xmm(arg2), CMP_LT
                    break;
                case OP_LE:
                    | cmpps xmm(arg1), xmm(arg2), CMP_LE
                    break;
                case OP_GT:
                    /* cmpps doesn't support >, so we can eitherjust swap
                     * the arguments for <=, or we use
                     * "not-less-than-or-equal", which sounds like it's what
                     * we're after but has subtle differences that might
                     * bite us in the ass */
                    | .if use_accurate_gt
                    | cmpps xmm(arg2), xmm(arg1), CMP_LE
                    | movaps xmm(arg1), xmm(arg2)
                    | .else
                    | cmpps xmm(arg1), xmm(arg2), CMP_NLE
                    | .endif
                    break;
                case OP_GE:
                    | .if use_accurate_gt
                    | cmpps xmm(arg2), xmm(arg1), CMP_LT
                    | movaps xmm(arg1), xmm(arg2)
                    | .else
                    | cmpps xmm(arg1), xmm(arg2), CMP_NLT
                    | .endif
                    break;
                case OP_EQ:
                    /* TODO: see if SSE4 PTEST can be used sometimes */
                    | cmpps xmm(arg1), xmm(arg2), CMP_EQ
                    break;
                case OP_NEQ:
                    /* TODO: see if SSE4 PTEST can be used sometimes */
                    | cmpps xmm(arg1), xmm(arg2), CMP_NE
                    break;
                case OP_MIN:
                    | minps xmm(arg1), xmm(arg2)
                    break;
                case OP_MAX:
                    | maxps xmm(arg1), xmm(arg2)
                    break;
                default:
                    snprintf(errbuf, sizeof(errbuf), "BINARY: didn't recognize operator '%c'", *pos);
                    return RERR(errbuf, pos);
                    break;
            }

            /* xmm0 is the return register for floating point values */
            if (arg1 != 0) {
                | movaps xmm0, xmm(arg1)
            }
        }
        break;

        case OP_UNKNOWN:
            snprintf(errbuf, sizeof(errbuf), "OP_UNKNOWN, didn't recognize operator '%c'", *pos);
            return RERR(errbuf, pos);

        default:
            snprintf(errbuf, sizeof(errbuf), "ERROR: didn't recognize operator '%c'", *pos);
            return RERR(errbuf, pos);
    }

    |  ret

    return ROK(pos);
}

const char *sample_code = "(min (10 20 30 40) (40 20 30 10))";

int main(int argc, char *argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <integer> <float>\n", argv[0]);
        return 1;
    }

    int num = atoi(argv[1]);
    const float fl = (float)atof(argv[2]);
    int fnum = float_bitmask(fl);

    // Generate the code.  Each line appends to a buffer in
    // "state", but the code in this buffer is not fully linked
    // yet because labels can be referenced before they are
    // defined.
    //
    // The run-time value of C variable "num" is substituted
    // into the immediate value of the instruction.
    /* |  mov eax, num */
    /* |  ret */

    // Link the code and write it to executable memory.
    /* int (*fptr)() = jitcode(&state); */
    int ret = 42;

    dasm_init(Dst, 1);
    dasm_setup(Dst, actions);

    /* |  shufps xmm0, xmm0, 0 */

    /* do some pushes to see what kind of values we get */
    /* |  push dword fnum */
    /* |  push dword num */
    /* |  push dword fnum */
    /* |  push dword num */
    /* undo the stack modifications */
    /* |  add rsp, 4*8 */

    struct error err = compile(sample_code);
    if (err.msg) {
        fprintf(stderr, "err: %s\n", err.msg);
    }

    /* save the stack pointer to rbx */
    |  mov rbx, rsp
    /* align stack to 16 bytes, reserve 16 bytes, load dqword */
    |  and rsp, -16
    |  sub rsp, 16
    |  mov dword [rsp], fnum
    |  mov dword [rsp+4], fnum
    |  mov dword [rsp+8], fnum
    |  mov dword [rsp+12], fnum
    |  movaps xmm0, [rsp]
    /* push rbx (which contains the val of the stack ptr) on the stack */
    |  push rbx
    /* SSE 4 dot product, also try a macro of SSE2/3 instr later */
    /* |  dpps xmm0, xmm0, 0xf1 */
    /* |  dot_prod_sse4 xmm0, xmm0 */
    /* |  dot_prod_sse3 xmm0, xmm0 */
    |  dot_prod_sse2 xmm0, xmm0
    /* restore the saved stack pointer */
    |  pop rsp
    |  ret

    float (*fltf)(float) = jitcode(Dst);
    float fret = fltf(fnum);
    printf("the float value is %f == %f (0x%x == 0x%x) memcpy: 0x%x\n", fl, fret,
            *(int *)&fl, *(int *)&fret, fnum);

    free_jitcode(fltf);
    dasm_free(Dst);

    return ret;
}
